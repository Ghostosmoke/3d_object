# ============================================================================
# 3D SINE WAVE TORUS KNOT - Ursina Engine
# ============================================================================
# Описание: Анимация тор-узла (Torus Knot), движущегося по синусоидальной
#           траектории с вращением и процедурной генерацией геометрии
# Требования: pip install ursina numpy
# Математика: Тор-узел (p=2, q=3) — узел на поверхности тора
# Версия: 1.0
# ============================================================================

# ============================================================================
# ИМПОРТ БИБЛИОТЕК
# ============================================================================
from ursina import *  # Основной движок Ursina для 3D графики
# Включает: Entity, Mesh, Camera, Scene, Shader и др.
from ursina.shaders import lit_with_shadows_shader  # Шейдеры с освещением (опционально)
import numpy as np  # NumPy для математических вычислений
# Векторные операции, тригонометрия, линейная алгебра
import math  # Стандартная математическая библиотека (альтернатива numpy)

# ============================================================================
# ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ
# ============================================================================
# Создаём главное окно приложения Ursina с настройками
app = Ursina(
    title="3D Sine Wave Knot",  # Заголовок окна (отображается в title bar)
    resolution=(1280, 720),  # Разрешение окна: 1280×720 (HD 720p)
    # Можно изменить на (1920, 1080) для Full HD
    vsync=True,  # Вертикальная синхронизация
    # True = плавная картинка без разрывов (ограничивает FPS)
    # False = максимальный FPS (возможны артефакты)
    borderless=False,  # False = окно с рамкой, True = без рамки
    fullscreen=False,  # False = оконный режим, True = полный экран
    editable=True  # Разрешить редактирование сцены в runtime
)


# ============================================================================
# ГЕНЕРАЦИЯ ГЕОМЕТРИИ ТОР-УЗЛА
# ============================================================================
def generate_torus_knot_mesh():
    """
    Генерирует вершины и треугольники для Тор-узла процедурно.

    Математическое описание:
    ------------------------
    Тор-узел — это замкнутая кривая, обвивающая тор (бублик) определённое
    количество раз в двух направлениях. Обозначается как T(p, q) где:
    • p — количество обходов вокруг большой оси тора (meridional)
    • q — количество обходов вокруг малой оси тора (longitudinal)

    Наш узел: T(2, 3) — trefoil knot (трилистник)
    • 2 обхода вокруг центральной оси тора
    • 3 обхода вокруг трубки тора

    Параметрические уравнения:
    --------------------------
    x(t) = (R + r·cos(q·t)) · cos(p·t)
    y(t) = (R + r·cos(q·t)) · sin(p·t)
    z(t) = r·sin(q·t)

    Где:
    • R = 2 — большой радиус тора (расстояние от центра до центра трубки)
    • r = 1 — малый радиус (радиус самой трубки, в формуле косинуса)
    • t ∈ [0, 2π] — параметр вдоль кривой
    • p = 2, q = 3 — коэффициенты узла

    Структура меша:
    ---------------
    • tubular_segments = 64 — количество сегментов вдоль основной кривой
    • radial_segments = 16 — количество сегментов вокруг трубки (кольцо)
    • tube_radius = 0.3 — радиус трубки (толщина узла)
    • Итого вершин: 64 × 16 = 1024
    • Итого треугольников: 64 × 16 × 2 = 2048

    Алгоритм построения:
    --------------------
    1. Вычисляем точки вдоль основной кривой узла (knot_func)
    2. Для каждой точки строим локальную систему координат (Frenet frame):
       - tangent — касательный вектор (направление кривой)
       - normal — нормальный вектор (перпендикулярно касательной)
       - binormal — бинормальный вектор (перпендикулярно обоим)
    3. Вокруг каждой точки создаём кольцо вершин (трубку)
    4. Соединяем соседние кольца треугольниками

    Возвращает:
    -----------
    vertices : list[np.array] — список координат вершин (x, y, z)
    triangles : list[list[int]] — список индексов для треугольников
    """

    # ------------------------------------------------------------------------
    # ПАРАМЕТРЫ ГЕНЕРАЦИИ
    # ------------------------------------------------------------------------
    tube_radius = 0.3  # Радиус трубки (толщина узла)
    # Меньше = тоньше, Больше = толще
    radial_segments = 16  # Количество сегментов вокруг трубки
    # Меньше = угловатая трубка, Больше = гладкая
    tubular_segments = 64  # Количество сегментов вдоль кривой узла

    # Меньше = угловатый узел, Больше = гладкий

    # ------------------------------------------------------------------------
    # ФУНКЦИЯ ТОР-УЗЛА (ПАРАМЕТРИЧЕСКИЕ УРАВНЕНИЯ)
    # ------------------------------------------------------------------------
    def knot_func(t):
        """
        Вычисляет координаты точки на тор-узле для параметра t.

        Параметр t:
        -----------
        t ∈ [0, 2π] — параметр вдоль кривой
        t = 0 — начало узла
        t = 2π — конец узла (совпадает с началом, т.к. узел замкнут)

        Формула T(2, 3):
        ----------------
        x = (2 + cos(3t)) · cos(2t)
        y = (2 + cos(3t)) · sin(2t)
        z = sin(3t)

        Возвращает:
        -----------
        np.array([x, y, z]) — координаты точки в 3D пространстве
        """
        x = (2 + np.cos(3 * t)) * np.cos(2 * t)
        y = (2 + np.cos(3 * t)) * np.sin(2 * t)
        z = np.sin(3 * t)
        return np.array([x, y, z])

    # ------------------------------------------------------------------------
    # ШАГ 1: ГЕНЕРАЦИЯ ТОЧЕК ВДОЛЬ ОСНОВНОЙ КРИВОЙ
    # ------------------------------------------------------------------------
    # np.linspace создаёт равномерно распределённые точки
    # start=0, stop=2π, num=64, endpoint=False
    # endpoint=False — последняя точка НЕ включается (чтобы не дублировать первую)
    ts = np.linspace(0, 2 * np.pi, tubular_segments, endpoint=False)

    # Вычисляем координаты всех точек кривой
    # points[i] = координаты i-й точки вдоль узла
    points = np.array([knot_func(t) for t in ts])

    # ------------------------------------------------------------------------
    # ШАГ 2: ГЕНЕРАЦИЯ ВЕРШИН ТРУБКИ
    # ------------------------------------------------------------------------
    vertices = []  # Список всех вершин меша

    # Проходим по каждой точке основной кривой
    for i, center in enumerate(points):
        # --------------------------------------------------------------------
        # ВЫЧИСЛЕНИЕ ЛОКАЛЬНОЙ СИСТЕМЫ КООРДИНАТ (Frenet Frame)
        # --------------------------------------------------------------------
        # Нужно создать кольцо вершин вокруг каждой точки.
        # Для этого нужна локальная система координат, ориентированная
        # вдоль кривой (иначе трубка будет скручена неправильно).

        # Следующая точка вдоль кривой (для вычисления касательной)
        next_center = points[(i + 1) % len(points)]
        # % len(points) — зацикливание (последняя точка → первая)

        # Касательный вектор (направление кривой в этой точке)
        tangent = next_center - center
        # Нормализация (единичная длина для корректных вычислений)
        norm = np.linalg.norm(tangent)
        if norm > 0:
            tangent = tangent / norm

        # --------------------------------------------------------------------
        # ВЫЧИСЛЕНИЕ НОРМАЛИ И БИНОРМАЛИ
        # --------------------------------------------------------------------
        # Вектор "вверх" для ориентации (глобальная ось Z)
        up = np.array([0, 0, 1])

        # Проблема: если касательная параллельна up (dot product ≈ 1),
        # cross product даст нулевой вектор. Нужно выбрать другой up.
        if abs(np.dot(tangent, up)) > 0.9:
            # Касательная почти параллельна Z → используем Y как up
            up = np.array([0, 1, 0])

        # Нормальный вектор (перпендикулярно касательной и up)
        normal = np.cross(tangent, up)
        norm = np.linalg.norm(normal)
        if norm > 0:
            normal = normal / norm

        # Бинормальный вектор (перпендикулярно касательной и нормали)
        # Образует правую тройку: tangent × normal = binormal
        binormal = np.cross(tangent, normal)

        # --------------------------------------------------------------------
        # СОЗДАНИЕ КОЛЬЦА ВЕРШИН ВОКРУГ ТОЧКИ
        # --------------------------------------------------------------------
        # Для каждой точки основной кривой создаём кольцо из radial_segments вершин
        for j in range(radial_segments):
            # Угол для текущей вершины кольца (0 to 2π)
            angle = 2 * np.pi * j / radial_segments

            # Смещение от центра трубки в плоскости normal-binormal
            # cos(angle) * normal + sin(angle) * binormal — единичный вектор
            # Умножаем на tube_radius для получения нужного радиуса
            offset = (np.cos(angle) * normal + np.sin(angle) * binormal) * tube_radius

            # Финальная координата вершины
            vertex = center + offset
            vertices.append(vertex)

    # ------------------------------------------------------------------------
    # ШАГ 3: ГЕНЕРАЦИЯ ТРЕУГОЛЬНИКОВ (ИНДЕКСОВ)
    # ------------------------------------------------------------------------
    triangles = []  # Список треугольников (каждый — 3 индекса вершин)

    # Проходим по каждому сегменту вдоль кривой
    for i in range(tubular_segments):
        # Проходим по каждому сегменту вокруг трубки
        for j in range(radial_segments):
            # --------------------------------------------------------------
            # ВЫЧИСЛЕНИЕ ИНДЕКСОВ ВЕРШИН
            # --------------------------------------------------------------
            # Нумерация вершин:
            # vertex_index = i * radial_segments + j
            # где i — индекс вдоль кривой, j — индекс вокруг трубки

            # Текущая вершина
            current = i * radial_segments + j

            # Следующая вершина вдоль кривой (тот же угол кольца)
            next_i = ((i + 1) % tubular_segments) * radial_segments + j
            # % tubular_segments — зацикливание (последний сегмент → первый)

            # Следующая вершина вокруг трубки (тот же сегмент кривой)
            next_j = i * radial_segments + ((j + 1) % radial_segments)
            # % radial_segments — зацикливание кольца

            # Диагональная вершина (следующая по кривой + следующая по кольцу)
            next_ij = ((i + 1) % tubular_segments) * radial_segments + ((j + 1) % radial_segments)

            # --------------------------------------------------------------
            # СОЗДАНИЕ ДВУХ ТРЕУГОЛЬНИКОВ НА КВАДРАТ
            # --------------------------------------------------------------
            # Каждый квадрат между 4 вершинами разбиваем на 2 треугольника:
            #
            # next_i ----- next_ij
            #   |           /  |
            #   |    T2   /    |
            #   |       /      |
            # current ----- next_j
            #      \    T1    /
            #       \        /
            #        \      /

            # Треугольник 1: current → next_ij → next_i
            triangles.append([current, next_ij, next_i])

            # Треугольник 2: current → next_j → next_ij
            triangles.append([current, next_j, next_ij])

    # Возвращаем данные для создания меша
    return vertices, triangles


# ============================================================================
# СОЗДАНИЕ МЕША (3D МОДЕЛИ)
# ============================================================================
print("=" * 60)
print("Генерация тор-узла...")
print("=" * 60)

try:
    # Вызываем функцию генерации геометрии
    verts, tris = generate_torus_knot_mesh()

    # Выводим статистику для отладки
    print(f"✓ Вершин создано: {len(verts)} (ожидалось: {64 * 16} = 1024)")
    print(f"✓ Треугольников создано: {len(tris)} (ожидалось: {64 * 16 * 2} = 2048)")

    # Создаём объект Mesh из вершин и треугольников
    # mode='triangle' — интерпретировать данные как отдельные треугольники
    knot_model = Mesh(
        vertices=verts,  # Список координат вершин (1024 точки)
        triangles=tris,  # Список индексов для треугольников (2048 треугольников)
        mode='triangle',  # Режим отрисовки: заполненные треугольники
        # Альтернативы: 'line' (каркас), 'point' (точки)
        colors=None,  # Можно задать цвет для каждой вершины (None = единый цвет)
        uvs=None  # Текстуры (None = без текстур)
    )

    # Генерируем нормали для правильного освещения
    # Нормали — векторы, перпендикулярные каждой грани
    # Без нормалей освещение будет работать некорректно (все грани одинаково яркие)
    knot_model.generate_normals()

    print("✓ Меш тор-узла создан успешно!")
    print(f"✓ Нормали сгенерированы: {len(knot_model.normals)} нормалей")

except Exception as e:
    # Обработка ошибок генерации (например, ошибка в математике вершин)
    print(f"✗ Ошибка генерации меша: {type(e).__name__}: {e}")
    print("⚠ Используем запасной вариант: куб")
    verts, tris = [], []
    knot_model = 'cube'  # Встроенная модель Ursina

# ============================================================================
# СОЗДАНИЕ СЦЕНЫ
# ============================================================================
print("=" * 60)
print("Создание сцены...")
print("=" * 60)

# ------------------------------------------------------------------------
# ПОЛ (ПЛОСКОСТЬ)
# ------------------------------------------------------------------------
# Создаём плоскость для ощущения глубины и пространства
ground = Entity(
    model='plane',  # Плоская модель (2D поверхность в 3D)
    scale=(20, 1, 20),  # Размер: 20×1×20 единиц (ширина, высота, глубина)
    # Высота=1 чтобы плоскость имела толщину
    color=color.dark_gray,  # Тёмно-серый цвет (RGB: ~64, 64, 64)
    texture='white_cube',  # Текстура куба (создаёт эффект плитки/сетки)
    collider='box',  # Коллизия: коробка (для физики, если нужно)
    shader=None  # Шейдер (None = стандартное освещение)
)
print("✓ Пол создан")

# ------------------------------------------------------------------------
# НЕБО (ФОН СЦЕНЫ)
# ------------------------------------------------------------------------
# Sky создаёт сферу вокруг камеры с заданным цветом
# Это фон, который виден везде, где нет объектов
Sky(
    color=color.rgb(20, 20, 40)  # Тёмно-синий цвет (почти чёрный с оттенком синего)
    # Альтернативы:
    # texture='sky_sunset'  # Текстура заката (встроенная в Ursina)
    # texture='sky_default' # Стандартное небо
)
print("✓ Небо создано")

# ------------------------------------------------------------------------
# ТОР-УЗЕЛ (ГЛАВНЫЙ ОБЪЕКТ)
# ------------------------------------------------------------------------
# Entity — базовый класс для всех объектов в сцене Ursina
knot = Entity(
    model=knot_model,  # 3D модель (наш сгенерированный меш или 'cube')
    color=color.cyan,  # Цвет: циан (голубой, RGB: 0, 255, 255)
    # Можно использовать: color.red, color.green, color.rgb(r,g,b)
    scale=0.5,  # Масштаб: 0.5 = половина от исходного размера
    # Исходный размер узла ≈ 4 единицы, после scale ≈ 2
    position=(-10, 0, 0),  # Начальная позиция: x=-10, y=0, z=0
    # Узел начнёт движение слева от центра сцены
    rotation=(0, 0, 0),  # Начальный угол вращения (x, y, z) в градусах
    texture=None,  # Текстура (None = сплошной цвет)
    shader=None  # Шейдер (None = стандартное освещение)
)
print("✓ Тор-узел добавлен на сцену")

# ------------------------------------------------------------------------
# ОСВЕЩЕНИЕ
# ------------------------------------------------------------------------
# PointLight — точечный источник света (как лампочка)
# Свет будет следовать за узлом (parent=knot)
# Это создаёт динамические блики на поверхности при вращении
light = PointLight(
    parent=knot,  # Привязка к узлу: свет движется вместе с ним
    position=(2, 2, 2),  # Смещение света относительно родителя (локальные координаты)
    # Свет находится справа-сверху-спереди от узла
    color=color.white,  # Цвет света: белый (полный спектр)
    shadows=False,  # Тени отключены для стабильности (True = требует больше ресурсов)
    attenuation=(0.5, 0.5, 0.5)  # Затухание света: (константа, линейное, квадратичное)
    # Можно раскомментировать для настройки дальности
)
print("✓ Источник света создан")

# ------------------------------------------------------------------------
# КАМЕРА
# ------------------------------------------------------------------------
# EditorCamera — камера с управлением мышью (как в 3D редакторах)
# Позволяет вращать, двигать и приближать сцену во время выполнения
camera = EditorCamera(
    rotation_x=10,  # Начальный наклон камеры вверх/вниз (градусы)
    # Положительный = смотрим сверху, отрицательный = снизу
    rotation_y=-45,  # Начальный поворот камеры вокруг оси Y (градусы)
    # Отрицательный = поворот влево
    distance=40,  # Расстояние от камеры до точки фокуса
    # Меньше = ближе к объекту, больше = дальше
    speed=10,  # Скорость перемещения камеры (можно настроить)
    min_distance=5,  # Минимальное расстояние зума (защита от прохода сквозь объект)
    max_distance=100  # Максимальное расстояние зума
)
print("✓ Камера настроена")
print(f"  • Позиция камеры: {camera.position}")
print(f"  • Расстояние до объекта: {camera.distance}")

# ============================================================================
# АНИМАЦИЯ И ЛОГИКА ДВИЖЕНИЯ
# ============================================================================
# Глобальная переменная для отслеживания времени/пройденного пути
time_tracker = 0


def update():
    """
    Функция update() вызывается автоматически каждый кадр (frame).
    Частота вызовов зависит от FPS (обычно 60 раз в секунду).

    time.dt — delta time: время в секундах с последнего кадра.
    Использование dt обеспечивает одинаковую скорость на разных FPS.
    Без dt: на 30 FPS движение будет в 2 раза медленнее, чем на 60 FPS.
    """
    global time_tracker  # Объявляем глобальной, чтобы сохранять значение между кадрами

    # --------------------------------------------------------------------
    # РАСЧЁТ СКОРОСТИ ДВИЖЕНИЯ
    # --------------------------------------------------------------------
    # speed = 4 * time.dt
    # 4 — базовая скорость (единиц в секунду)
    # time.dt — множитель для независимости от FPS
    # Пример: при 60 FPS, dt ≈ 0.0167, speed ≈ 0.067 единиц за кадр
    speed = 4 * time.dt

    # --------------------------------------------------------------------
    # ДВИЖЕНИЕ ВПЕРЁД ПО ОСИ X
    # --------------------------------------------------------------------
    # Постепенно увеличиваем X-координату → объект движется слева направо
    knot.x += speed

    # Обновляем трекер времени (пройденное расстояние по X)
    time_tracker += speed

    # --------------------------------------------------------------------
    # ДВИЖЕНИЕ ПО СИНУСОИДЕ (ОСЬ Y — ВЕРХ/ВНИЗ)
    # --------------------------------------------------------------------
    # Формула: y = A * sin(ω * t)
    # A (амплитуда) = 3 — максимальное отклонение от центра (вверх/вниз на 3 единицы)
    # ω (частота) = 0.5 — скорость колебаний (меньше = медленнее волна)
    # t (время) = time_tracker — пройденное расстояние
    # Результат: плавная синусоидальная волна от -3 до +3
    knot.y = np.sin(time_tracker * 0.5) * 3

    # --------------------------------------------------------------------
    # ДВИЖЕНИЕ ПО КОСИНУСОИДЕ (ОСЬ Z — ВПЕРЁД/НАЗАД)
    # --------------------------------------------------------------------
    # Формула: z = A * cos(ω * t)
    # Используем косинус вместо синуса для фазового сдвига на 90°
    # Это создаёт эффект спирали/винта при движении
    # Амплитуда = 2 (меньше чем Y, чтобы не перегружать движение)
    knot.z = np.cos(time_tracker * 0.5) * 2

    # --------------------------------------------------------------------
    # ВРАЩЕНИЕ ВОКРУГ СОБСТВЕННЫХ ОСЕЙ
    # --------------------------------------------------------------------
    # Вращение по Y (горизонтальное) — быстрее
    # 50 — градусов в секунду
    # time.dt — обеспечивает плавность независимо от FPS
    knot.rotation_y += 50 * time.dt

    # Вращение по Z (вокруг оси взгляда) — медленнее
    # Добавляет визуальную сложность движению
    knot.rotation_z += 20 * time.dt

    # --------------------------------------------------------------------
    # ЦИКЛИЧЕСКИЙ СБРОС ПОЗИЦИИ
    # --------------------------------------------------------------------
    # Когда узел уходит за правую границу экрана (x > 10)
    # Возвращаем его влево (x = -10) для бесконечного цикла
    if knot.x > 10:
        knot.x = -10  # Сброс позиции по X
        time_tracker = 0  # Сброс трекера времени (для синусоид)
        print("↻ Цикл завершён, сброс позиции...")  # Отладочное сообщение


# ============================================================================
# ПОЛЬЗОВАТЕЛЬСКИЙ ИНТЕРФЕЙС (UI)
# ============================================================================
# Text — 2D текст поверх 3D сцены (не зависит от камеры)
# position — координаты в экранных единицах от -1 до 1
# (-0.85, 0.45) = левый верхний угол

Text(
    text='ЛКМ: Вращать | Колесо: Зум | ПКМ: Сдвиг',  # Текст подсказки
    position=(-0.85, 0.45),  # Позиция: x=-0.85 (слева), y=0.45 (сверху)
    scale=1,  # Размер шрифта (1 = стандартный)
    color=color.gray,  # Цвет текста: серый (чтобы не отвлекал)
    origin=(-0.5, 0.5)  # Точка привязки: левый верхний угол текста
)

# Вторая строка подсказки (чуть ниже первой)
Text(
    text='ESC: Выйти | R: Сброс камеры',
    position=(-0.85, 0.40),
    scale=1,
    color=color.gray,
    origin=(-0.5, 0.5)
)

# Отображение текущих координат для отладки (опционально)
debug_text = Text(
    text='',
    position=(0.85, -0.45),
    scale=0.8,
    color=color.lime,
    origin=(0.5, -0.5)
)


# Обновление отладочного текста в каждом кадре
def update_debug():
    """Обновляет отладочную информацию на экране"""
    debug_text.text = (
        f'Позиция: ({knot.x:.2f}, {knot.y:.2f}, {knot.z:.2f})\n'
        f'FPS: {int(1 / time.dt) if time.dt > 0 else 0}\n'
        f'Время: {time_tracker:.2f}\n'
        f'Вершин: {len(verts)}, Треугольников: {len(tris)}'
    )


# Добавляем функцию в update (через вызов в конце update())
original_update = update


def update():
    original_update()
    update_debug()


# ============================================================================
# ЗАПУСК ПРИЛОЖЕНИЯ
# ============================================================================
print("=" * 60)
print("Запуск приложения...")
print("=" * 60)
print("Управление:")
print("  • ЛКМ + drag — вращение камеры")
print("  • Колесо мыши — зум (приближение/удаление)")
print("  • ПКМ + drag — перемещение камеры")
print("  • ESC — закрыть окно")
print("=" * 60)

# app.run() — запускает главный цикл приложения
# После этой строки код не выполняется (до закрытия окна)
# Цикл: обработка событий → update() → рендеринг → повтор
app.run()

# ============================================================================
# КОНЕЦ ПРОГРАММЫ
# ============================================================================
